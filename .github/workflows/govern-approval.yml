name: "Approval Gate"
#run-name: "${{ format('üïµÔ∏è Approval Listener | {0} | issue #{1} | run #{2}', github.ref_name, github.event.issue.number, github.run_number) }}"
run-name: "${{ format('üïµÔ∏è {0} | issue #{1} | run #{2}', github.event.issue.title, github.event.issue.number, github.run_number) }}"

on:
  issue_comment:
    types: [created]

permissions:
  contents: read
  issues: write
  actions: write
  id-token: write

env:
  APPROVERS_CSV: "francisbachabi81,user2"
  # Fallback username; prefer setting a secret GH_PAT_ACTOR to the PAT owner login
  PAT_ACTOR: "francisbachabi81"
  SYSTEM_MARKER: "<!-- system:approval-final -->"

concurrency:
  group: approval-listener-${{ github.event.issue.id }}-${{ github.event.comment.id }}
  cancel-in-progress: true

jobs:
  gate:
    # Skip bot-authored comments (including CodeRabbit), only run for humans
    if: >-
      ${{
        github.event.issue.state == 'open' &&
        github.event.comment.user.type != 'Bot' &&
        github.event.comment.user.login != 'coderabbitai' &&
        github.event.comment.user.login != 'coderabbitai[bot]'
      }}
    runs-on: ubuntu-latest
    steps:
      # Decide whether to proceed; everything else is gated on this.
      - name: Guard / short-circuit
        id: guard
        shell: bash
        env:
          BODY:   ${{ github.event.comment.body }}
          AUTHOR: ${{ github.event.comment.user.login }}
          STATE:  ${{ github.event.issue.state }}
          MARK:   ${{ env.SYSTEM_MARKER }}
        run: |
          set -euo pipefail
          proceed=1

          echo "Author: $AUTHOR"
          echo "State:  $STATE"
          echo "Body:   $BODY"

          # must start with "/approve " or "/reject " (allow any whitespace)
          if [[ ! "$BODY" =~ ^/(approve|reject)[[:space:]]+ ]]; then
            echo "Guard: not an approve/reject command"
            proceed=0
          fi

          # issue must be open
          if [[ "$STATE" != "open" ]]; then
            echo "Guard: issue not open"
            proceed=0
          fi

          # ignore our own final/system comments (contain marker)
          if grep -q "$MARK" <<<"$BODY"; then
            echo "Guard: system marker found (final comment), skipping"
            proceed=0
          fi

          # ignore comments authored by the PAT owner (prevents loop on our final comment)
          # if [[ -n "${PAT_OWNER:-}" && "$AUTHOR" == "$PAT_OWNER" ]]; then
          #   echo "Guard: comment authored by PAT owner (${PAT_OWNER}); skipping to avoid loop."
          #   proceed=0
          # fi

          echo "proceed=$proceed" >> "$GITHUB_OUTPUT"

      - name: Parse command & runId
        id: parse
        if: ${{ steps.guard.outputs.proceed == '1' }}
        shell: bash
        run: |
          cmd="${{ github.event.comment.body }}"
          cmd="$(echo "$cmd" | tr -d '\r')"   # strip CR if pasted
          action="${cmd%% *}"
          runid="${cmd#* }"
          runid="$(echo "$runid" | xargs)"    # trim
          echo "action=$action" >> $GITHUB_OUTPUT
          echo "runid=$runid"   >> $GITHUB_OUTPUT

      - name: Check approver is authorized
        if: ${{ steps.guard.outputs.proceed == '1' }}
        run: |
          IFS=',' read -ra USERS <<< "${APPROVERS_CSV}"
          ok=0
          for u in "${USERS[@]}"; do
            [ "$u" = "${{ github.event.comment.user.login }}" ] && ok=1
          done
          [ $ok -eq 1 ] || { echo "Not authorized"; exit 1; }

      - name: Extract stack/product/plane-or-env from issue title
        id: meta
        if: ${{ steps.guard.outputs.proceed == '1' }}
        shell: bash
        run: |
          set -euo pipefail
          title='${{ github.event.issue.title }}'
          echo "Title: $title"

          # "APPROVAL: platform-app | pub-dev | main | #42 | run 123456789 (a1b2c3d)"
          #       -> stack=platform-app, product=pub, third=dev

          stack=""
          product=""
          third=""

          # Try new bar/pipe format first: APPROVAL: <stack> | <product>-<envOrPlane> | ...
          if [[ "$title" =~ ^APPROVAL:\ ([^|[:space:]]+)[[:space:]]*\|[[:space:]]*([A-Za-z0-9._-]+)-([A-Za-z0-9._-]+) ]]; then
            stack="${BASH_REMATCH[1]}"
            product="${BASH_REMATCH[2]}"
            third="${BASH_REMATCH[3]}"
          else
            # Fallback to legacy space-delimited
            stack=$(awk '{print $2}' <<<"$title")
            product=$(awk '{print $3}' <<<"$title")
            third=$(awk '{print $4}' <<<"$title")
          fi

          # Basic sanity
          if [[ -z "$stack" || -z "$product" || -z "$third" ]]; then
            echo "::error::Could not parse stack/product/third from issue title"
            echo "Parsed -> stack='$stack' product='$product' third='$third'"
            exit 1
          fi

          echo "stack=$stack"     >> "$GITHUB_OUTPUT"
          echo "product=$product" >> "$GITHUB_OUTPUT"
          echo "third=$third"     >> "$GITHUB_OUTPUT"

          echo "Parsed -> stack='$stack' product='$product' third='$third'"

      - name: Approve ‚Üí dispatch apply (with PAT), close, then final comment
        if: ${{ steps.guard.outputs.proceed == '1' && steps.parse.outputs.action == '/approve' }}
        uses: actions/github-script@v7
        with:
          # github-token: ${{ secrets.GH_PAT_WORKFLOW }}
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const MARK = process.env.SYSTEM_MARKER || '<!-- system:approval-final -->';
            const PAT_OWNER = process.env.GH_PAT_ACTOR || process.env.PAT_ACTOR || 'github-actions[bot]';

            const stack     = `${{ steps.meta.outputs.stack }}`.trim();
            const product   = `${{ steps.meta.outputs.product }}`.trim();
            const third     = `${{ steps.meta.outputs.third }}`.trim();   // plane or env
            const planRunId = `${{ steps.parse.outputs.runid }}`.trim();

            // Decide which apply workflow + inputs to call
            let workflow_id, inputs;
            if (stack === "shared-network") {
              workflow_id = "shared-network-governed-plan-apply.yml";
              inputs = { mode: "apply", product, plane: third, plan_run_id: planRunId };
            } else if (stack === "core") {
              workflow_id = "core-governed-plan-apply.yml";
              inputs = { mode: "apply", product, plane: third, plan_run_id: planRunId };
            } else if (stack === "platform-app") {
              workflow_id = "platform-app-governed-plan-apply.yml";
              inputs = { mode: "apply", product, env: third, plan_run_id: planRunId };
            } else if (stack === "observability") {
              workflow_id = "observability-governed-plan-apply.yml";
              inputs = { mode: "apply", product, env: third, plan_run_id: planRunId };
            } else if (stack === "platform-registry") {
              workflow_id = "registry-apply.yml";
              inputs = { product, env: third, plan_run_id: planRunId };
            } else if (stack === "app-gateway-config") {
              workflow_id = "app-gateway-config-governed-plan-apply.yml";
              inputs = { mode: "apply", product, plane: third, plan_run_id: planRunId };
            } else if (stack === "afd-config") {
              workflow_id = "afd-config-governed-plan-apply.yml";
              inputs = { mode: "apply", product, plane: third, plan_run_id: planRunId };
            } else {
              core.setFailed(`Unknown stack in issue title: ${stack}`);
              return;
            }

            // Confirm workflow exists and we can see it
            try {
              const wf = await github.rest.actions.getWorkflow({
                owner: context.repo.owner,
                repo:  context.repo.repo,
                workflow_id, // same string you're about to use for dispatch
              });
              core.info(`Workflow resolved: id=${wf.data.id}, name=${wf.data.name}, state=${wf.data.state}, path=${wf.data.path}`);
            } catch (e) {
              core.error(`getWorkflow failed for '${workflow_id}': ${e.status} ${e.message}`);
              core.error(`This almost always means filename/path or permissions/SSO.`);
              throw e; // bail early; dispatch will also 404 anyway
            }

            // Dynamic branch ref from the original plan run
            let ref = context.ref?.startsWith('refs/heads/')
              ? context.ref.replace('refs/heads/', '')
              : 'main';
            
            try {
              const run = await github.rest.actions.getWorkflowRun({
                owner: context.repo.owner,
                repo:  context.repo.repo,
                run_id: Number(planRunId)
              });
              if (run?.data?.head_branch) {
                ref = run.data.head_branch;
              }
            } catch (e) {
              core.warning(`Could not resolve branch from plan run ${planRunId}: ${e.message}`);
            }

            // Dispatch the apply on that exact branch
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo:  context.repo.repo,
              workflow_id,
              ref,
              inputs
            });

            // best-effort: find the new apply run URL for the comment
            const started = Date.now();
            const deadlineMs = 20000;
            const sleep = (ms) => new Promise(r => setTimeout(r, ms));
            let applyRunHtml = null;

            try {
              const patActor = PAT_OWNER.toLowerCase();
              while ((Date.now() - started) < deadlineMs && !applyRunHtml) {
                const runs = await github.rest.actions.listWorkflowRuns({
                  owner: context.repo.owner,
                  repo:  context.repo.repo,
                  workflow_id,
                  branch: ref,
                  event: 'workflow_dispatch',
                  per_page: 10
                });
                const freshCutoff = new Date(Date.now() - 5 * 60 * 1000);
                const found = (runs.data.workflow_runs || []).find(r =>
                  (r.actor?.login || '').toLowerCase() === patActor &&
                  new Date(r.created_at) > freshCutoff
                );
                if (found?.html_url) {
                  applyRunHtml = found.html_url;
                  break;
                }
                await sleep(2000);
              }
            } catch (e) {
              core.warning(`Could not locate apply run URL: ${e.message}`);
            }

            // Close FIRST to avoid a second trigger
            await github.rest.issues.update({
              owner: context.repo.owner,
              repo:  context.repo.repo,
              issue_number: context.issue.number,
              state: "closed"
            });

            // Small delay to let the "closed" state propagate before we post our final comment
            await new Promise(r => setTimeout(r, 2000));

            // Final comment
            const repoUrl     = `https://github.com/${context.repo.owner}/${context.repo.repo}`;
            const planRunUrl  = `${repoUrl}/actions/runs/${planRunId}`;
            const applyTabUrl = `${repoUrl}/actions/workflows/${workflow_id}`;
            const applyLine   = applyRunHtml
              ? `- **Apply run**: ${applyRunHtml}`
              : `- **Apply workflow**: ${applyTabUrl}`;

            const body = `${MARK}
            ‚úÖ **Approved** by @${context.actor}.
            - Stack: \`${stack}\`
            - Product: \`${product}\`
            - Env/Plane: \`${third}\`
            - Branch ref: \`${ref}\`
            - **Plan run**: ${planRunUrl}
            ${applyLine}`;

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo:  context.repo.repo,
              issue_number: context.issue.number,
              body
            });

      - name: Reject ‚Üí close, then final comment
        if: ${{ steps.guard.outputs.proceed == '1' && steps.parse.outputs.action == '/reject' }}
        uses: actions/github-script@v7
        with:
          # github-token: ${{ secrets.GH_PAT_WORKFLOW }}
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const MARK = process.env.SYSTEM_MARKER || '<!-- system:approval-final -->';

            // Close FIRST
            await github.rest.issues.update({
              owner: context.repo.owner,
              repo:  context.repo.repo,
              issue_number: context.issue.number,
              state: "closed"
            });

            // Let closure propagate before commenting
            await new Promise(r => setTimeout(r, 2000));

            const body = `${MARK}
            ‚ùå **Rejected** by @${context.actor}.`;

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo:  context.repo.repo,
              issue_number: context.issue.number,
              body
            });
