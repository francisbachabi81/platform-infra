name: provision-secrets
run-name: ${{ format('{0}-{1}-{2}-kvt{3}', github.workflow, inputs.product, inputs.env, inputs.kv_sequence) }}

on:
  workflow_dispatch:
    inputs:
      env:
        description: "Environment"
        type: choice
        options: [dev, qa, uat, prod]
        default: dev
      product:
        description: "Product (hrz = Azure Gov, pub = Azure Commercial)"
        type: choice
        options: [hrz, pub]
        default: hrz
      region_short:
        description: "Region short code (default: usaz for hrz, cus for pub)"
        type: string
        default: ""
      kv_sequence:
        description: "2-digit Key Vault sequence (01, 02, ...)."
        type: string
        default: "01"
      manifest_path:
        description: |-
          Optional explicit schema path. If omitted:
            seq=01 → stacks/provision-secrets/<product>.secrets.schema.json
            seq>01 → stacks/provision-secrets/<product>-kvt<seq>-secrets.schema.json
        type: string
        default: ""
      literal_bundle_secret:
        description: "GitHub secret that holds JSON object for literal_bundle_ref entries"
        type: string
        default: "SEED_JSON"

permissions:
  id-token: write
  contents: read

jobs:
  seed:
    runs-on: ubuntu-latest
    environment: ${{ inputs.env }}

    steps:
      - uses: actions/checkout@v4

      # Select cloud/tenant/subscription/client-id by product×env (Option A)
      - name: Select cloud/tenant/subscription
        id: subsel
        shell: bash
        run: |
          set -euo pipefail
          PLANE="${{ inputs.plane }}"
          PRODUCT="${{ inputs.product }}"
    
          if [ "$PRODUCT" = "hrz" ]; then
            CLOUD_ENV="AzureUSGovernment"
            ARM_ENV="usgovernment"
            TENANT="${{ secrets.AZ_TENANT_HRZ }}"
            CLIENT_ID="${{ secrets.AZURE_CLIENT_ID_HRZ }}"
            AUDIENCE="api://AzureADTokenExchangeUSGov"
            case "$PLANE" in
              nonprod) SUB="${{ secrets.AZ_SUB_HRZ_NONPROD }}";;
              prod)    SUB="${{ secrets.AZ_SUB_HRZ_PROD }}";;
              *) echo "Unknown plane: $PLANE"; exit 1;;
            esac
          else
            CLOUD_ENV="AzureCloud"
            ARM_ENV="public"
            TENANT="${{ secrets.AZ_TENANT_PUB }}"
            CLIENT_ID="${{ secrets.AZURE_CLIENT_ID_PUB }}"
            AUDIENCE="api://AzureADTokenExchange"
            case "$PLANE" in
              nonprod) SUB="${{ secrets.AZ_SUB_PUB_NONPROD }}";;
              prod)    SUB="${{ secrets.AZ_SUB_PUB_PROD }}";;
              *) echo "Unknown plane: $PLANE"; exit 1;;
            esac
          fi
    
          echo "CLOUD_ENV=$CLOUD_ENV" >> $GITHUB_OUTPUT
          echo "ARM_ENV=$ARM_ENV"     >> $GITHUB_OUTPUT
          echo "TENANT=$TENANT"       >> $GITHUB_OUTPUT
          echo "SUB=$SUB"             >> $GITHUB_OUTPUT
          echo "CLIENT_ID=$CLIENT_ID" >> $GITHUB_OUTPUT
          echo "AUDIENCE=$AUDIENCE"   >> $GITHUB_OUTPUT
    
          {
            echo "ARM_ENVIRONMENT=$ARM_ENV"
            echo "ARM_TENANT_ID=$TENANT"
            echo "ARM_SUBSCRIPTION_ID=$SUB"
            echo "TF_VAR_tenant_id=$TENANT"
            echo "TF_VAR_subscription_id=$SUB"
            echo "TF_VAR_product=${{ inputs.product }}"
          } >> $GITHUB_ENV
    
      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id:       ${{ steps.subsel.outputs.CLIENT_ID }}   # <-- use selected client id
          tenant-id:       ${{ steps.subsel.outputs.TENANT }}
          subscription-id: ${{ steps.subsel.outputs.SUB }}
          environment:     ${{ steps.subsel.outputs.CLOUD_ENV }}
          audience:        ${{ steps.subsel.outputs.AUDIENCE }}

      - name: Resolve region, manifest, RG & KV names
        id: cfg
        shell: bash
        env:
          ENV: ${{ inputs.env }}
          PRODUCT: ${{ inputs.product }}
          REGION_INPUT: ${{ inputs.region_short }}
          KV_SEQ: ${{ inputs.kv_sequence }}
          MANIFEST_INPUT: ${{ inputs.manifest_path }}
          ARM_ENV: ${{ steps.subsel.outputs.ARM_ENV }}
        run: |
          set -euo pipefail

          # region defaults by product
          if [ -n "${REGION_INPUT}" ]; then
            REGION="${REGION_INPUT}"
          else
            REGION=$([ "${PRODUCT}" = "hrz" ] && echo "usaz" || echo "cus")
          fi

          # two-digit sequence validation
          if ! [[ "${KV_SEQ}" =~ ^[0-9]{2}$ ]]; then
            echo "kv_sequence must be two digits (e.g., 01, 02)"; exit 1
          fi

          # default manifest path based on product + sequence
          if [ -n "${MANIFEST_INPUT}" ]; then
            MANIFEST="${MANIFEST_INPUT}"
          else
            BASE="stacks/provision-secrets"
            if [ "${KV_SEQ}" = "01" ]; then
              MANIFEST="${BASE}/${PRODUCT}.secrets.schema.json"
            else
              MANIFEST="${BASE}/${PRODUCT}-kvt${KV_SEQ}-secrets.schema.json"
            fi
          fi

          # naming convention
          RG="rg-${PRODUCT}-${ENV}-${REGION}-01"
          KV="kvt-${PRODUCT}-${ENV}-${REGION}-${KV_SEQ}"

          # endpoint suffix for storage conn strings
          if [ "${ARM_ENV}" = "usgovernment" ]; then
            STORAGE_SUFFIX="core.usgovcloudapi.net"
          else
            STORAGE_SUFFIX="core.windows.net"
          fi

          # allow manifest to override RG/KV if provided
          if [ -f "${MANIFEST}" ]; then
            M_RG=$(jq -r '.resourceGroup // empty' "${MANIFEST}") || true
            M_KV=$(jq -r '.keyVaultName // empty' "${MANIFEST}") || true
            [ -n "${M_RG}" ] && RG="${M_RG}"
            [ -n "${M_KV}" ] && KV="${M_KV}"
          fi

          # sanity
          test -f "${MANIFEST}" || { echo "Manifest not found: ${MANIFEST}"; exit 1; }
          jq -e . "${MANIFEST}" > /dev/null

          {
            echo "region=${REGION}"
            echo "rg=${RG}"
            echo "kv=${KV}"
            echo "manifest=${MANIFEST}"
            echo "storage_suffix=${STORAGE_SUFFIX}"
          } >> "$GITHUB_OUTPUT"

          echo "Resolved:"
          echo "  env/product: ${ENV}/${PRODUCT}"
          echo "  region:      ${REGION}"
          echo "  kv:          ${KV}"
          echo "  rg:          ${RG}"
          echo "  manifest:    ${MANIFEST}"
          echo "  suffix:      ${STORAGE_SUFFIX}"

      - name: Open KV (PNA Enable + Allow)
        shell: bash
        run: |
          az keyvault update -g "${{ steps.cfg.outputs.rg }}" -n "${{ steps.cfg.outputs.kv }}" --public-network-access Enabled --only-show-errors
          az keyvault update -g "${{ steps.cfg.outputs.rg }}" -n "${{ steps.cfg.outputs.kv }}" --default-action Allow --only-show-errors
          sleep 10

      - name: Seed secrets from schema
        shell: bash
        env:
          MANIFEST: ${{ steps.cfg.outputs.manifest }}
          RG: ${{ steps.cfg.outputs.rg }}
          KV: ${{ steps.cfg.outputs.kv }}
          STORAGE_SUFFIX: ${{ steps.cfg.outputs.storage_suffix }}
          BUNDLE_NAME: ${{ inputs.literal_bundle_secret }}
          BUNDLE_JSON: ${{ secrets[inputs.literal_bundle_secret] }}
        run: |
          set -euo pipefail

          # mask bundle values (optional)
          LB_JSON="${BUNDLE_JSON:-}"
          if [ -n "$LB_JSON" ]; then
            echo "Using literal bundle: ${BUNDLE_NAME}"
            echo "$LB_JSON" | jq -r 'to_entries[].value' | while IFS= read -r v; do echo "::add-mask::$v"; done
          fi

          set_kv_secret () {
            local name="$1" value="$2" content_type="$3" expires_on="$4" not_before="$5" tags_json="$6"
            echo "::add-mask::$value"
            args=(--vault-name "$KV" --name "$name" --value "$value" --only-show-errors)
            [ -n "$content_type" ] && args+=(--content-type "$content_type")
            [ -n "$expires_on" ] && args+=(--expires "$expires_on")
            [ -n "$not_before" ] && args+=(--not-before "$not_before")
            if [ -n "${tags_json:-}" ] && [ "$tags_json" != "null" ]; then
              mapfile -t tag_kv <<<"$(echo "$tags_json" | jq -r 'to_entries[] | "\(.key)=\(.value)"')"
              if [ "${#tag_kv[@]}" -gt 0 ]; then args+=(--tags); args+=("${tag_kv[@]}"); fi
            fi
            local tries=8 delay=4
            for ((i=1;i<=tries;i++)); do
              if az keyvault secret set "${args[@]}" >/dev/null 2>err.log; then
                echo "✓ $name"; rm -f err.log; return 0; fi
              if grep -qiE 'Forbidden|ForbiddenByFirewall' err.log; then
                echo "… retrying $name in ${delay}s"; sleep "$delay"; delay=$(( delay<30 ? delay*2 : 30 )); continue; fi
              echo "✗ set $name failed:"; cat err.log >&2; rm -f err.log; return 1
            done
            echo "✗ set $name timed out"; [ -f err.log ] && cat err.log >&2; rm -f err.log || true; return 1
          }

          count=$(jq '.secrets | length' "$MANIFEST")
          echo "Processing $count entries..."
          jq -c '.secrets[]' "$MANIFEST" | while IFS= read -r row; do
            name=$(echo "$row" | jq -r '.name')
            src_type=$(echo "$row" | jq -r '.source.type')
            ctype=$(echo "$row" | jq -r '.contentType // empty')
            expiresOn=$(echo "$row" | jq -r '.expiresOn // empty')
            notBefore=$(echo "$row" | jq -r '.notBefore // empty')
            tags=$(echo "$row" | jq -r '.tags // empty')

            case "$src_type" in
              storage_primary_key)
                acct=$(echo "$row" | jq -r '.source.account')
                val=$(az storage account keys list -n "$acct" -g "$RG" --query "[0].value" -o tsv)
                set_kv_secret "$name" "$val" "$ctype" "$expiresOn" "$notBefore" "$tags"
                ;;
              storage_conn_str)
                acct=$(echo "$row" | jq -r '.source.account')
                key=$(az storage account keys list -n "$acct" -g "$RG" --query "[0].value" -o tsv)
                val="DefaultEndpointsProtocol=https;AccountName=${acct};AccountKey=${key};EndpointSuffix=${STORAGE_SUFFIX}"
                set_kv_secret "$name" "$val" "$ctype" "$expiresOn" "$notBefore" "$tags"
                ;;
              storage_blob_endpoint)
                acct=$(echo "$row" | jq -r '.source.account')
                val=$(az storage account show -n "$acct" -g "$RG" --query "primaryEndpoints.blob" -o tsv)
                set_kv_secret "$name" "$val" "$ctype" "$expiresOn" "$notBefore" "$tags"
                ;;
              cosmos_primary_key)
                acct=$(echo "$row" | jq -r '.source.account')
                val=$(az cosmosdb keys list -n "$acct" -g "$RG" --type keys --query "primaryMasterKey" -o tsv)
                set_kv_secret "$name" "$val" "$ctype" "$expiresOn" "$notBefore" "$tags"
                ;;
              redis_primary_key)
                rname=$(echo "$row" | jq -r '.source.name')
                val=$(az redis list-keys -n "$rname" -g "$RG" --query "primaryKey" -o tsv)
                set_kv_secret "$name" "$val" "$ctype" "$expiresOn" "$notBefore" "$tags"
                ;;
              redis_conn_str)
                rname=$(echo "$row" | jq -r '.source.name')
                host=$(az redis show -n "$rname" -g "$RG" --query "hostName" -o tsv)
                key=$(az redis list-keys -n "$rname" -g "$RG" --query "primaryKey" -o tsv)
                val="rediss://${host}:6380?password=${key}"
                set_kv_secret "$name" "$val" "$ctype" "$expiresOn" "$notBefore" "$tags"
                ;;
              keyvault_uri)
                val=$(az keyvault show -g "$RG" -n "$KV" --query "properties.vaultUri" -o tsv)
                set_kv_secret "$name" "$val" "$ctype" "$expiresOn" "$notBefore" "$tags"
                ;;
              appinsights_ikey)
                appi=$(echo "$row" | jq -r '.source.name')
                val=$(az monitor app-insights component show -g "$RG" -a "$appi" --query "instrumentationKey" -o tsv)
                set_kv_secret "$name" "$val" "$ctype" "$expiresOn" "$notBefore" "$tags"
                ;;
              appinsights_connstr)
                appi=$(echo "$row" | jq -r '.source.name')
                val=$(az monitor app-insights component show -g "$RG" -a "$appi" --query "connectionString" -o tsv)
                set_kv_secret "$name" "$val" "$ctype" "$expiresOn" "$notBefore" "$tags"
                ;;
              postgres_endpoint)
                pgsrv=$(echo "$row" | jq -r '.source.server')
                host=$(az postgres flexible-server show -g "$RG" -n "$pgsrv" --query "fullyQualifiedDomainName" -o tsv)
                val="postgresql://${host}:5432"
                set_kv_secret "$name" "$val" "$ctype" "$expiresOn" "$notBefore" "$tags"
                ;;
              postgres_conn_str)
                pgsrv=$(echo "$row" | jq -r '.source.server')
                db=$(echo "$row"   | jq -r '.source.database')
                sslmode=$(echo "$row" | jq -r '.source.sslmode // "require"')
                user_key=$(echo "$row" | jq -r '.source.username_ref')
                pass_key=$(echo "$row" | jq -r '.source.password_ref')

                if [ -z "$LB_JSON" ]; then echo "✗ postgres_conn_str requires bundle"; exit 1; fi
                user=$(echo "$LB_JSON" | jq -r --arg k "$user_key" '.[$k]')
                pass=$(echo "$LB_JSON" | jq -r --arg k "$pass_key" '.[$k]')
                [ "$user" = "null" ] && { echo "✗ bundle missing $user_key"; exit 1; }
                [ "$pass" = "null" ] && { echo "✗ bundle missing $pass_key"; exit 1; }

                host=$(az postgres flexible-server show -g "$RG" -n "$pgsrv" --query "fullyQualifiedDomainName" -o tsv)
                val="postgres://${user}:${pass}@${host}:5432/${db}?sslmode=${sslmode}"
                set_kv_secret "$name" "$val" "$ctype" "$expiresOn" "$notBefore" "$tags"
                ;;
              literal_bundle_ref)
                lk=$(echo "$row" | jq -r '.source.key')
                if [ -z "$LB_JSON" ]; then echo "✗ literal_bundle_ref but no bundle provided: $name"; exit 1; fi
                val=$(echo "$LB_JSON" | jq -r --arg k "$lk" '.[$k]')
                [ "$val" = "null" ] && { echo "✗ key '$lk' not found in bundle"; exit 1; }
                set_kv_secret "$name" "$val" "$ctype" "$expiresOn" "$notBefore" "$tags"
                ;;
              file)
                path=$(echo "$row" | jq -r '.source.path')
                [ -f "$path" ] || { echo "✗ File not found: $path"; exit 1; }
                val=$(cat "$path")
                set_kv_secret "$name" "$val" "$ctype" "$expiresOn" "$notBefore" "$tags"
                ;;
              *)
                echo "✗ Unknown source.type '$src_type' for secret '$name'"; exit 1;;
            esac
            sleep 0.1
          done

      - name: Close KV (PNA Disable + Deny)
        if: ${{ always() }}
        shell: bash
        run: |
          az keyvault update -g "${{ steps.cfg.outputs.rg }}" -n "${{ steps.cfg.outputs.kv }}" --default-action Deny --only-show-errors
          az keyvault update -g "${{ steps.cfg.outputs.rg }}" -n "${{ steps.cfg.outputs.kv }}" --public-network-access Disabled --only-show-errors
          az keyvault show -g "${{ steps.cfg.outputs.rg }}" -n "${{ steps.cfg.outputs.kv }}" \
            --query "{pna:properties.publicNetworkAccess, firewallDefaultAction:properties.networkAcls.defaultAction}" -o table || true
