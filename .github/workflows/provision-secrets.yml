name: provision-secrets
run-name: ${{ format('{0}-{1}-{2} {3}', github.workflow, inputs.product, inputs.env, (inputs.destroy && 'destroy' || (inputs.apply && 'apply' || 'plan'))) }}

on:
  workflow_dispatch:
    inputs:
      env:
        description: "Environment (lane)"
        type: choice
        options: [dev, qa, uat, prod]
        default: dev
      product:
        description: "Product (hrz = Azure Gov, pub = Azure Commercial)"
        type: choice
        options: [hrz, pub]
        default: hrz
      region_short:
        description: "Region short code used in naming (e.g., cus for Commercial, usaz for Gov)"
        type: string
        default: ""
      manifest_path:
        description: "Override manifest path (leave blank to auto: stacks/envs/<env>/secrets.manifest.json)"
        type: string
        default: ""
      resource_group:
        description: "Override Resource Group (leave blank to auto-build from convention)"
        type: string
        default: ""
      key_vault_name:
        description: "Override Key Vault name (leave blank to auto-build from convention)"
        type: string
        default: ""
      literal_bundle_secret:
        description: "GitHub secret name holding JSON bundle of literal values"
        type: string
        default: "SEED_JSON"

permissions:
  id-token: write
  contents: read

jobs:
  seed:
    runs-on: ubuntu-latest
    environment: ${{ inputs.env }}

    steps:
      - uses: actions/checkout@v4

      # Select cloud/tenant/subscription/client-id based on product×env (Option A)
      - name: Select cloud/tenant/subscription/client-id
        id: subsel
        shell: bash
        run: |
          set -euo pipefail
          ENV="${{ inputs.env }}"          # dev|qa|uat|prod
          PRODUCT="${{ inputs.product }}"  # hrz|pub

          if [ "$PRODUCT" = "hrz" ]; then
            CLOUD_ENV="AzureUSGovernment"
            ARM_ENV="usgovernment"
            TENANT="${{ secrets.AZ_TENANT_HRZ }}"
            CLIENT_ID="${{ secrets.AZURE_CLIENT_ID_HRZ }}"
            case "$ENV" in
              dev)  SUB="${{ secrets.AZ_SUB_HRZ_DEV }}";;
              qa)   SUB="${{ secrets.AZ_SUB_HRZ_QA }}";;
              uat)  SUB="${{ secrets.AZ_SUB_HRZ_UAT }}";;
              prod) SUB="${{ secrets.AZ_SUB_HRZ_PROD }}";;
              *) echo "Unknown env: $ENV"; exit 1;;
            esac
          else
            CLOUD_ENV="AzureCloud"
            ARM_ENV="public"
            TENANT="${{ secrets.AZ_TENANT_PUB }}"
            CLIENT_ID="${{ secrets.AZURE_CLIENT_ID_PUB }}"
            case "$ENV" in
              dev)  SUB="${{ secrets.AZ_SUB_PUB_DEV }}";;
              qa)   SUB="${{ secrets.AZ_SUB_PUB_QA }}";;
              uat)  SUB="${{ secrets.AZ_SUB_PUB_UAT }}";;
              prod) SUB="${{ secrets.AZ_SUB_PUB_PROD }}";;
              *) echo "Unknown env: $ENV"; exit 1;;
            esac
          fi

          echo "CLOUD_ENV=$CLOUD_ENV" >> $GITHUB_OUTPUT
          echo "ARM_ENV=$ARM_ENV"     >> $GITHUB_OUTPUT
          echo "TENANT=$TENANT"       >> $GITHUB_OUTPUT
          echo "SUB=$SUB"             >> $GITHUB_OUTPUT
          echo "CLIENT_ID=$CLIENT_ID" >> $GITHUB_OUTPUT

          {
            echo "ARM_ENVIRONMENT=$ARM_ENV"
            echo "ARM_TENANT_ID=$TENANT"
            echo "ARM_SUBSCRIPTION_ID=$SUB"
            echo "ARM_CLIENT_ID=$CLIENT_ID"
          } >> $GITHUB_ENV

      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id:       ${{ steps.subsel.outputs.CLIENT_ID }}
          tenant-id:       ${{ steps.subsel.outputs.TENANT }}
          subscription-id: ${{ steps.subsel.outputs.SUB }}
          environment:     ${{ steps.subsel.outputs.CLOUD_ENV }}

      - name: Resolve settings (env/product → manifest path, RG, KV, region, suffixes)
        id: resolve
        shell: bash
        env:
          ENV: ${{ inputs.env }}
          PRODUCT: ${{ inputs.product }}
          REGION_INPUT: ${{ inputs.region_short }}
          MANIFEST_INPUT: ${{ inputs.manifest_path }}
          RG_INPUT: ${{ inputs.resource_group }}
          KV_INPUT: ${{ inputs.key_vault_name }}
          BUNDLE_SECRET_NAME: ${{ inputs.literal_bundle_secret }}
          ARM_ENV: ${{ steps.subsel.outputs.ARM_ENV }}
        run: |
          set -euo pipefail

          # 1) Manifest path
          if [ -n "${MANIFEST_INPUT}" ]; then
            MANIFEST="${MANIFEST_INPUT}"
          else
            MANIFEST="stacks/envs/${ENV}/secrets.manifest.json"
          fi

          # 2) Region short: allow override; else default by product
          if [ -n "${REGION_INPUT}" ]; then
            REGION="${REGION_INPUT}"
          else
            if [ "${PRODUCT}" = "hrz" ]; then
              REGION="usaz"
            else
              REGION="cus"
            fi
          fi

          # 3) Build names from convention if not overridden or present in manifest
          # Convention: rg-<product>-<env>-<region>-01 , kvt-<product>-<env>-<region>-01
          # You can tweak the prefixes/suffix here if your convention changes.
          RG="${RG_INPUT}"
          KV="${KV_INPUT}"

          if [ -z "${RG}" ]; then
            RG="rg-${PRODUCT}-${ENV}-${REGION}-01"
          fi
          if [ -z "${KV}" ]; then
            KV="kvt-${PRODUCT}-${ENV}-${REGION}-01"
          fi

          # 4) If manifest exists, allow it to override (only if explicit RG/KV were not provided)
          if [ -f "${MANIFEST}" ]; then
            M_RG=$(jq -r '.resourceGroup // empty' "${MANIFEST}") || true
            M_KV=$(jq -r '.keyVaultName // empty' "${MANIFEST}") || true
            if [ -z "${RG_INPUT}" ] && [ -n "${M_RG}" ]; then RG="${M_RG}"; fi
            if [ -z "${KV_INPUT}" ] && [ -n "${M_KV}" ]; then KV="${M_KV}"; fi
          fi

          # 5) Azure Storage endpoint suffix (Gov vs Commercial)
          if [ "${ARM_ENV}" = "usgovernment" ]; then
            STORAGE_SUFFIX="core.usgovcloudapi.net"
          else
            STORAGE_SUFFIX="core.windows.net"
          fi

          # Checks
          test -n "${RG}" && test -n "${KV}" || { echo "Could not resolve Resource Group and/or Key Vault."; exit 1; }

          {
            echo "env=${ENV}"
            echo "product=${PRODUCT}"
            echo "region=${REGION}"
            echo "manifest=${MANIFEST}"
            echo "rg=${RG}"
            echo "kv=${KV}"
            echo "bundle_secret_name=${BUNDLE_SECRET_NAME}"
            echo "storage_suffix=${STORAGE_SUFFIX}"
          } >> "$GITHUB_OUTPUT"

          echo "Resolved:"
          echo "  env:      ${ENV}"
          echo "  product:  ${PRODUCT}"
          echo "  region:   ${REGION}"
          echo "  manifest: ${MANIFEST}"
          echo "  rg:       ${RG}"
          echo "  kv:       ${KV}"
          echo "  suffix:   ${STORAGE_SUFFIX}"
          echo "  bundle:   ${BUNDLE_SECRET_NAME}"

      - name: Validate manifest exists
        run: |
          test -f "${{ steps.resolve.outputs.manifest }}" || { echo "Manifest not found"; exit 1; }
          jq -e . "${{ steps.resolve.outputs.manifest }}" > /dev/null

      # Temporarily open KV (PNA Enabled + firewall Allow); close later
      - name: Enable Key Vault Public Network Access
        if: ${{ success() && steps.resolve.outputs.kv != '' && steps.resolve.outputs.rg != '' }}
        shell: bash
        run: |
          set -euo pipefail
          RG="${{ steps.resolve.outputs.rg }}"
          KV="${{ steps.resolve.outputs.kv }}"

          echo "Enabling PNA + opening firewall (Allow) on KV: $KV (RG: $RG)"
          az keyvault update -g "$RG" -n "$KV" --public-network-access Enabled >/dev/null
          az keyvault update -g "$RG" -n "$KV" --default-action Allow >/dev/null
          sleep 10

      - name: Seed secrets
        shell: bash
        env:
          BUNDLE_NAME: ${{ steps.resolve.outputs.bundle_secret_name }}
          BUNDLE_JSON: ${{ secrets[steps.resolve.outputs.bundle_secret_name] }}
          STORAGE_SUFFIX: ${{ steps.resolve.outputs.storage_suffix }}
        run: |
          set -euo pipefail

          MANIFEST="${{ steps.resolve.outputs.manifest }}"
          RG="${{ steps.resolve.outputs.rg }}"
          KV="${{ steps.resolve.outputs.kv }}"

          LITERAL_BUNDLE_SECRET_NAME="${BUNDLE_NAME}"
          LITERAL_BUNDLE_JSON="${BUNDLE_JSON:-}"

          echo "Target RG: $RG ; KV: $KV ; bundle: ${LITERAL_BUNDLE_SECRET_NAME}"
          test -n "$RG" && test -n "$KV" || { echo "resourceGroup and keyVaultName required"; exit 1; }

          LB_JSON="${LITERAL_BUNDLE_JSON:-}"
          if [ -n "$LB_JSON" ]; then
            echo "Literal bundle provided via $LITERAL_BUNDLE_SECRET_NAME"
            echo "$LB_JSON" | jq -r 'to_entries[].value' | while IFS= read -r val; do
              echo "::add-mask::$val"
            done
          else
            echo "No literal bundle secret provided; literal_bundle_ref entries will fail if present."
          fi

          set_kv_secret () {
            local name="$1"
            local value="$2"
            local content_type="${3:-}"
            local expires_on="${4:-}"
            local not_before="${5:-}"
            local tags_json="${6:-}"

            echo "::add-mask::$value"
            args=(--vault-name "$KV" --name "$name" --value "$value" --only-show-errors)
            [ -n "$content_type" ] && args+=(--content-type "$content_type")
            [ -n "$expires_on" ] && args+=(--expires "$expires_on")
            [ -n "$not_before" ] && args+=(--not-before "$not_before")
            if [ -n "${tags_json:-}" ] && [ "$tags_json" != "null" ]; then
              mapfile -t tag_kv <<<"$(echo "$tags_json" | jq -r 'to_entries[] | "\(.key)=\(.value)"')"
              if [ "${#tag_kv[@]}" -gt 0 ]; then
                args+=(--tags)
                args+=("${tag_kv[@]}")
              fi
            fi

            local tries=8 delay=4
            for ((i=1; i<=tries; i++)); do
              if az keyvault secret set "${args[@]}" >/dev/null 2>err.log; then
                echo "✓ Set secret: $name"
                rm -f err.log
                return 0
              fi
              if grep -qiE 'Forbidden|ForbiddenByFirewall' err.log; then
                echo "… KV not ready for '$name' yet (attempt $i/$tries). Retrying in ${delay}s..."
                sleep "$delay"
                delay=$(( delay<30 ? delay*2 : 30 ))
                continue
              fi
              echo "✗ Failed setting '$name' (non-retryable):"
              cat err.log >&2
              rm -f err.log
              return 1
            done

            echo "✗ Timed out setting '$name' after ${tries} attempts."
            [ -f err.log ] && cat err.log >&2
            rm -f err.log || true
            return 1
          }

          count=$(jq '.secrets | length' "$MANIFEST")
          echo "Processing $count entries..."
          jq -c '.secrets[]' "$MANIFEST" | while IFS= read -r row; do
            name=$(echo "$row" | jq -r '.name')
            src_type=$(echo "$row" | jq -r '.source.type')
            ctype=$(echo "$row" | jq -r '.contentType // empty')
            expiresOn=$(echo "$row" | jq -r '.expiresOn // empty')
            notBefore=$(echo "$row" | jq -r '.notBefore // empty')
            tags=$(echo "$row" | jq -r '.tags // empty')

            case "$src_type" in
              storage_primary_key)
                acct=$(echo "$row" | jq -r '.source.account')
                val=$(az storage account keys list -n "$acct" -g "$RG" --query "[0].value" -o tsv)
                set_kv_secret "$name" "$val" "$ctype" "$expiresOn" "$notBefore" "$tags"
                ;;
              storage_conn_str)
                acct=$(echo "$row" | jq -r '.source.account')
                key=$(az storage account keys list -n "$acct" -g "$RG" --query "[0].value" -o tsv)
                val="DefaultEndpointsProtocol=https;AccountName=${acct};AccountKey=${key};EndpointSuffix=${STORAGE_SUFFIX}"
                set_kv_secret "$name" "$val" "$ctype" "$expiresOn" "$notBefore" "$tags"
                ;;
              storage_blob_endpoint)
                acct=$(echo "$row" | jq -r '.source.account')
                val=$(az storage account show -n "$acct" -g "$RG" --query "primaryEndpoints.blob" -o tsv)
                set_kv_secret "$name" "$val" "$ctype" "$expiresOn" "$notBefore" "$tags"
                ;;
              cosmos_primary_key)
                acct=$(echo "$row" | jq -r '.source.account')
                val=$(az cosmosdb keys list -n "$acct" -g "$RG" --type keys --query "primaryMasterKey" -o tsv)
                set_kv_secret "$name" "$val" "$ctype" "$expiresOn" "$notBefore" "$tags"
                ;;
              redis_primary_key)
                rname=$(echo "$row" | jq -r '.source.name')
                val=$(az redis list-keys -n "$rname" -g "$RG" --query "primaryKey" -o tsv)
                set_kv_secret "$name" "$val" "$ctype" "$expiresOn" "$notBefore" "$tags"
                ;;
              redis_conn_str)
                rname=$(echo "$row" | jq -r '.source.name')
                host=$(az redis show -n "$rname" -g "$RG" --query "hostName" -o tsv)
                key=$(az redis list-keys -n "$rname" -g "$RG" --query "primaryKey" -o tsv)
                val="rediss://${host}:6380?password=${key}"
                set_kv_secret "$name" "$val" "$ctype" "$expiresOn" "$notBefore" "$tags"
                ;;
              keyvault_uri)
                val=$(az keyvault show -g "$RG" -n "$KV" --query "properties.vaultUri" -o tsv)
                set_kv_secret "$name" "$val" "$ctype" "$expiresOn" "$notBefore" "$tags"
                ;;
              appinsights_ikey)
                appi=$(echo "$row" | jq -r '.source.name')
                val=$(az monitor app-insights component show -g "$RG" -a "$appi" --query "instrumentationKey" -o tsv)
                set_kv_secret "$name" "$val" "$ctype" "$expiresOn" "$notBefore" "$tags"
                ;;
              appinsights_connstr)
                appi=$(echo "$row" | jq -r '.source.name')
                val=$(az monitor app-insights component show -g "$RG" -a "$appi" --query "connectionString" -o tsv)
                set_kv_secret "$name" "$val" "$ctype" "$expiresOn" "$notBefore" "$tags"
                ;;
              postgres_endpoint)
                pgsrv=$(echo "$row" | jq -r '.source.server')
                host=$(az postgres flexible-server show -g "$RG" -n "$pgsrv" --query "fullyQualifiedDomainName" -o tsv)
                val="postgresql://${host}:5432"
                set_kv_secret "$name" "$val" "$ctype" "$expiresOn" "$notBefore" "$tags"
                ;;
              postgres_conn_str)
                pgsrv=$(echo "$row" | jq -r '.source.server')
                db=$(echo "$row"   | jq -r '.source.database')
                sslmode=$(echo "$row" | jq -r '.source.sslmode // "require"')
                user_key=$(echo "$row" | jq -r '.source.username_ref')
                pass_key=$(echo "$row" | jq -r '.source.password_ref')

                if [ -z "$LB_JSON" ]; then
                  echo "✗ postgres_conn_str requires bundle with username/password"; exit 1
                fi
                user=$(echo "$LB_JSON" | jq -r --arg k "$user_key" '.[$k]')
                pass=$(echo "$LB_JSON" | jq -r --arg k "$pass_key" '.[$k]')
                [ "$user" = "null" ] && { echo "✗ bundle missing $user_key"; exit 1; }
                [ "$pass" = "null" ] && { echo "✗ bundle missing $pass_key"; exit 1; }

                host=$(az postgres flexible-server show -g "$RG" -n "$pgsrv" --query "fullyQualifiedDomainName" -o tsv)
                val="postgres://${user}:${pass}@${host}:5432/${db}?sslmode=${sslmode}"
                set_kv_secret "$name" "$val" "$ctype" "$expiresOn" "$notBefore" "$tags"
                ;;
              literal_bundle_ref)
                lk=$(echo "$row" | jq -r '.source.key')
                if [ -z "$LB_JSON" ]; then
                  echo "✗ literal_bundle_ref but no bundle provided: $name"; exit 1
                fi
                val=$(echo "$LB_JSON" | jq -r --arg k "$lk" '.[$k]')
                [ "$val" = "null" ] && { echo "✗ key '$lk' not found in bundle"; exit 1; }
                set_kv_secret "$name" "$val" "$ctype" "$expiresOn" "$notBefore" "$tags"
                ;;
              file)
                path=$(echo "$row" | jq -r '.source.path')
                [ -f "$path" ] || { echo "✗ File not found: $path"; exit 1; }
                val=$(cat "$path")
                set_kv_secret "$name" "$val" "$ctype" "$expiresOn" "$notBefore" "$tags"
                ;;
              *)
                echo "✗ Unknown source.type '$src_type' for secret '$name'"; exit 1;;
            esac

            sleep 0.2
          done

          echo "✅ Completed seeding for $KV"

      - name: Disable Key Vault Public Network Access
        if: ${{ always() && steps.resolve.outputs.kv != '' && steps.resolve.outputs.rg != '' }}
        shell: bash
        run: |
          set -euo pipefail
          RG="${{ steps.resolve.outputs.rg }}"
          KV="${{ steps.resolve.outputs.kv }}"

          echo "Restoring KV firewall to Deny and disabling PNA for: $KV (RG: $RG)"
          az keyvault update -g "$RG" -n "$KV" --default-action Deny >/dev/null
          az keyvault update -g "$RG" -n "$KV" --public-network-access Disabled >/dev/null
          az keyvault show -g "$RG" -n "$KV" \
            --query "{pna:properties.publicNetworkAccess, firewallDefaultAction:properties.networkAcls.defaultAction}" -o table || true
