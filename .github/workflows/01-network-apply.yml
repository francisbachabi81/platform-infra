name: 01-network-apply
on:
  workflow_dispatch:
    inputs:
      product: { type: choice, options: [hrz, pub], required: true }
      plane:   { type: choice, options: [nonprod, prod], required: true }
      plan_run_id: { type: string, required: true }

permissions:
  id-token: write
  contents: read

env:
  ARM_USE_OIDC: true
  TF_IN_AUTOMATION: true

jobs:
  apply:
    name: "Apply (shared-network: ${{ inputs.plane }}.${{ inputs.product }})"
    runs-on: ubuntu-latest
    environment: ${{ inputs.plane }}
    defaults: { run: { working-directory: stacks/shared-network } }

    steps:
      - uses: actions/checkout@v4

      # (same cloud/sub selection & tfvars resolution as Plan) ----
      - name: Select cloud + subscriptions
        id: sel
        shell: bash
        run: |
          set -euo pipefail
          PLANE="${{ inputs.plane }}"
          PRODUCT="${{ inputs.product }}"
          if [ "$PRODUCT" = "hrz" ]; then
            CLOUD_ENV="AzureUSGovernment"; ARM_ENV="usgovernment"
            TENANT="${{ secrets.AZ_TENANT_HRZ }}"; CLIENT_ID="${{ secrets.AZURE_CLIENT_ID_HRZ }}"
            AUDIENCE="api://AzureADTokenExchangeUSGov"
            STATE_SUB="${{ secrets.AZ_SUB_STATE_HRZ != '' && secrets.AZ_SUB_STATE_HRZ || secrets.AZ_SUB_HRZ_PROD }}"
            case "$PLANE" in
              nonprod) TARGET_SUB="${{ secrets.AZ_SUB_HRZ_NONPROD }}";;
              prod)    TARGET_SUB="${{ secrets.AZ_SUB_HRZ_PROD }}";;
            esac
          else
            CLOUD_ENV="AzureCloud"; ARM_ENV="public"
            TENANT="${{ secrets.AZ_TENANT_PUB }}"; CLIENT_ID="${{ secrets.AZURE_CLIENT_ID_PUB }}"
            AUDIENCE="api://AzureADTokenExchange"
            STATE_SUB="${{ secrets.AZ_SUB_STATE_PUB != '' && secrets.AZ_SUB_STATE_PUB || secrets.AZ_SUB_PUB_PROD }}"
            case "$PLANE" in
              nonprod) TARGET_SUB="${{ secrets.AZ_SUB_PUB_NONPROD }}";;
              prod)    TARGET_SUB="${{ secrets.AZ_SUB_PUB_PROD }}";;
            esac
          fi
          echo "CLOUD_ENV=$CLOUD_ENV"   >> $GITHUB_OUTPUT
          echo "ARM_ENV=$ARM_ENV"       >> $GITHUB_OUTPUT
          echo "TENANT=$TENANT"         >> $GITHUB_OUTPUT
          echo "CLIENT_ID=$CLIENT_ID"   >> $GITHUB_OUTPUT
          echo "AUDIENCE=$AUDIENCE"     >> $GITHUB_OUTPUT
          echo "STATE_SUB=$STATE_SUB"   >> $GITHUB_OUTPUT
          echo "TARGET_SUB=$TARGET_SUB" >> $GITHUB_OUTPUT
          {
            echo "ARM_ENVIRONMENT=$ARM_ENV"
            echo "ARM_TENANT_ID=$TENANT"
            echo "ARM_CLIENT_ID=$CLIENT_ID"
            echo "TF_VAR_tenant_id=$TENANT"
            echo "TF_VAR_product=${PRODUCT}"
            echo "TF_VAR_subscription_id=$TARGET_SUB"
            echo "TF_VAR_hub_tenant_id=$TENANT"
            echo "TF_VAR_hub_subscription_id=$TARGET_SUB"
          } >> $GITHUB_ENV

      - name: Resolve tfvars & backend key
        id: paths
        shell: bash
        run: |
          set -euo pipefail
          PLANE="${{ inputs.plane }}"
          PRODUCT="${{ inputs.product }}"
      
          # If you set defaults.run.working-directory: stacks/shared-network,
          # you can just use TFVARS_DIR="tfvars" here.
          TFVARS_DIR="${GITHUB_WORKSPACE}/stacks/shared-network/tfvars"
      
          echo "🔎 Listing $TFVARS_DIR:"
          ls -la "$TFVARS_DIR" || true
      
          # Try both orderings and a few fallbacks
          candidates=(
            "${PLANE}.${PRODUCT}.tfvars"  # e.g., nonprod.pub.tfvars (recommended)
            "${PRODUCT}.${PLANE}.tfvars"  # e.g., pub.nonprod.tfvars
            "${PLANE}.tfvars"             # e.g., nonprod.tfvars
            "${PRODUCT}.tfvars"           # e.g., pub.tfvars
            "default.${PLANE}.tfvars"     # optional pattern
            "default.tfvars"              # optional catch-all
          )
      
          TFVARS_PATH=""
          for f in "${candidates[@]}"; do
            if [ -f "${TFVARS_DIR}/${f}" ]; then
              TFVARS_PATH="${TFVARS_DIR}/${f}"
              echo "✅ Using tfvars: ${f}"
              break
            fi
          done
      
          [ -n "${TFVARS_PATH}" ] || { echo "❌ Missing tfvars. Tried: ${candidates[*]}"; exit 1; }
      
          echo "TFVARS_PATH=${TFVARS_PATH}" >> "$GITHUB_OUTPUT"
          echo "STATE_RG=rg-core-infra-state"               >> "$GITHUB_OUTPUT"
          echo "STATE_SA=sacoretfstateinfra"               >> "$GITHUB_OUTPUT"
          echo "STATE_CONTAINER=tfstate"                   >> "$GITHUB_OUTPUT"
          echo "STATE_KEY=shared-network/${PRODUCT}/${PLANE}/terraform.tfstate" >> "$GITHUB_OUTPUT"

      - uses: hashicorp/setup-terraform@v3
        with: { terraform_version: "1.13.3" }

      - name: Azure Login (state subscription)
        uses: azure/login@v2
        with:
          client-id:       ${{ steps.sel.outputs.CLIENT_ID }}
          tenant-id:       ${{ steps.sel.outputs.TENANT }}
          subscription-id: ${{ steps.sel.outputs.STATE_SUB }}
          environment:     ${{ steps.sel.outputs.CLOUD_ENV }}
          audience:        ${{ steps.sel.outputs.AUDIENCE }}

      - name: Terraform Init (backend)
        env:
          ARM_USE_OIDC: true
          ARM_CLIENT_ID:       ${{ steps.sel.outputs.CLIENT_ID }}
          ARM_TENANT_ID:       ${{ steps.sel.outputs.TENANT }}
          ARM_SUBSCRIPTION_ID: ${{ steps.sel.outputs.STATE_SUB }}
          ARM_ENVIRONMENT:     ${{ steps.sel.outputs.ARM_ENV }}
        run: |
          terraform init -input=false -reconfigure \
            -backend-config="environment=${{ steps.sel.outputs.ARM_ENV }}" \
            -backend-config="tenant_id=${{ steps.sel.outputs.TENANT }}" \
            -backend-config="subscription_id=${{ steps.sel.outputs.STATE_SUB }}" \
            -backend-config="resource_group_name=${{ steps.paths.outputs.STATE_RG }}" \
            -backend-config="storage_account_name=${{ steps.paths.outputs.STATE_SA }}" \
            -backend-config="container_name=${{ steps.paths.outputs.STATE_CONTAINER }}" \
            -backend-config="key=${{ steps.paths.outputs.STATE_KEY }}" \
            -backend-config="use_azuread_auth=true"

      - name: Azure Login (target subscription)
        uses: azure/login@v2
        with:
          client-id:       ${{ steps.sel.outputs.CLIENT_ID }}
          tenant-id:       ${{ steps.sel.outputs.TENANT }}
          subscription-id: ${{ steps.sel.outputs.TARGET_SUB }}
          environment:     ${{ steps.sel.outputs.CLOUD_ENV }}
          audience:        ${{ steps.sel.outputs.AUDIENCE }}

      - name: Download approved plan artifact
        uses: dawidd6/action-download-artifact@v6
        with:
          run_id: ${{ inputs.plan_run_id }}
          name: shared-network-plan-${{ inputs.plan_run_id }}
          path: ${{ github.workspace }}/stacks/shared-network

      - name: Read plan metadata
        id: meta
        shell: bash
        run: |
          set -euo pipefail
          jq -r '.commit'       plan.meta.json | tee /tmp/_commit.txt
          jq -r '.backend_key'  plan.meta.json | tee /tmp/_backend.txt
          jq -r '.tenant'       plan.meta.json | tee /tmp/_tenant.txt
          jq -r '.target_sub'   plan.meta.json | tee /tmp/_target.txt
          jq -r '.state_sub'    plan.meta.json | tee /tmp/_state.txt
          echo "commit=$(cat /tmp/_commit.txt)"     >> "$GITHUB_OUTPUT"
          echo "backend=$(cat /tmp/_backend.txt)"   >> "$GITHUB_OUTPUT"
          echo "tenant=$(cat /tmp/_tenant.txt)"     >> "$GITHUB_OUTPUT"
          echo "target=$(cat /tmp/_target.txt)"     >> "$GITHUB_OUTPUT"
          echo "state=$(cat /tmp/_state.txt)"       >> "$GITHUB_OUTPUT"

      - name: Checkout exact commit used for the plan
        uses: actions/checkout@v4
        with:
          ref: ${{ steps.meta.outputs.commit }}

      - name: Use same Terraform version as plan
        id: tfver
        run: |
          v=$(head -n1 tf.version.txt | awk '{print $2}')
          echo "version=$v" >> "$GITHUB_OUTPUT"
      - uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ steps.tfver.outputs.version }}

      # Re-auth as you already do (state + target); keep it identical to plan

      - name: Terraform Init (same backend key as plan)
        env:
          ARM_USE_OIDC: true
          ARM_CLIENT_ID:       ${{ steps.sel.outputs.CLIENT_ID }}
          ARM_TENANT_ID:       ${{ steps.sel.outputs.TENANT }}
          ARM_SUBSCRIPTION_ID: ${{ steps.sel.outputs.STATE_SUB }}
          ARM_ENVIRONMENT:     ${{ steps.sel.outputs.ARM_ENV }}
        run: |
          terraform init -input=false -reconfigure \
            -backend-config="environment=${{ steps.sel.outputs.ARM_ENV }}" \
            -backend-config="tenant_id=${{ steps.meta.outputs.tenant }}" \
            -backend-config="subscription_id=${{ steps.meta.outputs.state }}" \
            -backend-config="resource_group_name=${{ steps.paths.outputs.STATE_RG }}" \
            -backend-config="storage_account_name=${{ steps.paths.outputs.STATE_SA }}" \
            -backend-config="container_name=${{ steps.paths.outputs.STATE_CONTAINER }}" \
            -backend-config="key=${{ steps.meta.outputs.backend }}" \
            -backend-config="use_azuread_auth=true"

      - name: Sanity checks before apply
        shell: bash
        run: |
          set -euo pipefail
          test -f tfplan || { echo "Missing tfplan"; exit 1; }
          # Make sure lockfile exists and matches providers we planned with
          test -f .terraform.lock.hcl || { echo "Missing .terraform.lock.hcl"; exit 1; }

      - name: Terraform Apply (re-using approved plan)
        run: terraform apply -input=false -auto-approve tfplan
